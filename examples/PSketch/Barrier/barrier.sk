int P = 2; // Number of processes
int T = 2; // number of tries, needed for bounded liveness
//bit[P] msg; // for communication between the processes
//bit[P] parity; // the parity of each process
//bit[P] finish; // indicates if the process have finished
//bit pass; // a process is the leader and communicates the decision

bit genComparison1 (bit[P] parity, bit pass, int i) {  
    int _which = ??;
    bit res;
    bit g1 = ?? ? pass : !pass;
    bit g2 = ?? ? parity[i] : !parity[i];
    assert 0 <= _which && _which <= 7;
    if (0 == _which) {  res = g1 && g2;  }
    if (1 == _which) {  res = !g1 && g2;  }
    if (2 == _which) {  res = g1 && !g2;  }
    if (3 == _which) {  res = !g1 && !g2;  }
    if (4 == _which) {  res = g1 || g2;  }
    if (5 == _which) {  res = !g1 || g2;  }
    if (6 == _which) {  res = g1 || !g2;  }
    if (7 == _which) {  res = !g1 || !g2;  }
    return res;
}

bit genComparison2 (bit[P] parity, bit pass, int i) {   
    int _which = ??;
    bit res;
    bit g1 = ?? ? pass : !pass;
    bit g2 = ?? ? parity[i] : !parity[i];
    assert 0 <= _which && _which <= 7;
     if (0 == _which) {  res = g1 && g2;  }
    if (1 == _which) {  res = !g1 && g2;  }
    if (2 == _which) {  res = g1 && !g2;  }
    if (3 == _which) {  res = !g1 && !g2;  }
    if (4 == _which) {  res = g1 || g2;  }
    if (5 == _which) {  res = !g1 || g2;  }
    if (6 == _which) {  res = g1 || !g2;  }
    if (7 == _which) {  res = !g1 || !g2;  }
    return res;
}


bit genComparisonA(bit[P] msg){
   bit res;
   bit g1 = msg[1];
   res = ?? ? g1 : !g1;
   return res;	
}

bit genComparisonB(bit[P] msg){
   bit res;
   bit g1 = msg[1];
   res = ?? ? g1 : !g1;
   return res;
}

bit sp () { return 1; }

bit main () implements sp {
    bit[P] finish;  
    bit[P] parity;
    bit[P] msg;
    bit pass;  

    fork (int i; P) {
        for (int t = 0; t < T; ++t) {
            if (i == 0){ //Process 1, leader
                bit cond1 = genComparisonA(msg);
                bit cond2 = genComparisonB(msg);
                reorder{
               	 atomic (cond1){ pass = 1; parity[0] = !parity[0]; };
               	 atomic (cond2){ pass = 0; parity[0] = !parity[0]; };
                  
               	}	
            }
            else{ //Process >0
                bit cond1 = genComparison1(parity,pass,i);
                bit cond2 = genComparison2(parity, pass,i);
                reorder{
                    finish[i]= ?? ? 1: 0;
                    atomic (cond1) {parity[i]=1; finish[i]=0; msg[0] =1;}; // pass barrier
                    atomic (cond2) {parity[i]=0; finish[i]=0; msg[0] =0;}; // pass barrier
                }
                }
          	  	
            }
        }
        return 1;
    }

