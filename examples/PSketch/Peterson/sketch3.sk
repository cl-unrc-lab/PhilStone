int P = 3; // Number of processes
int T = 5; // number of tries, needed for bounded liveness

bit genComparison (bit f1, bit f2, bit t1, bit t2) {   // 72/2 = 36
    int _which = ??;
    bit res;
    bit g1 = ?? ? f1 : f2;
    bit g2 = ?? ? t1 : t2;
    assert 0 <= _which && _which <= 7;
    if (0 == _which) {  res = g1 && g2;  }
    if (1 == _which) {  res = !g1 && g2;  }
    if (2 == _which) {  res = g1 && !g2;  }
    if (3 == _which) {  res = !g1 && !g2;  }
    if (4 == _which) {  res = g1 || g2; }
    if (5 == _which) {  res = !g1 || g2; }
    if (6 == _which) {  res = g1 || !g2; }
    if (7 == _which) {  res = !g1 || !g2; } 
    return res;
}


bit sp () { return 1; }

bit main () implements sp {
    bit[2][2] flag; // a flag in tournament style
    bit[2][2] turn; // a turn in tournament style

    fork (int i; P) {
        for (int t = 0; t < T; ++t) {
            if (i == 0){ //Process 0
                bit cond = genComparison(flag[1][0], flag[1][0], turn[1][1], turn[1][1]);
                atomic (cond){};
                int _which = ??;
		assert 0 <= _which && _which <= 3;
		reorder{   	
                    flag[1][0] = ?? ? 0 : 1;
                    flag[1][1] = ?? ? 0 : 1;
                    turn[1][0] = ?? ? 0 : 1;
                    turn[1][1] = ?? ? 0 : 1;
                }
            }
            else{ //Process 1 and 2
		for (int r=0; r<2; r++){ // these are for the rounds
                  // first round process 1 vs process 2     
                  int id = (i % 2);
   		  bit cond1 = genComparison(flag[0][id], flag[0][id+1], turn[0][0], turn[0][1]);
                  atomic (cond1){
		  };
                  bit cond2 = genComparison(flag[1][0], flag[1][1], turn[1][0],turn[1][1]);  	    
		  atomic (cond2){};
                  reorder{
	          	flag[1][0] = ?? ? 0 : 1;
			flag[1][1] = ?? ? 0 : 1;
 			flag[0][1] = ?? ? 0 : 1;
			flag[0][0] = ?? ? 0 : 1;
                        			
                  }
		}	
            }
        }
  }
  return 1;    
}

